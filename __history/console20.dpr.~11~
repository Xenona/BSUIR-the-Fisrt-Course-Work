program console20;

uses
  System.SysUtils;

type
  PPicElem=^TPicElems;

  Tdata = packed record
    title: string[20];
    year: integer;
    genre: string[10];
    place: string[15];
    shortDescr: string[100];
    userRate: integer;
    filename: string[15];
  end;


  TPicElems = record
    data: Tdata;
    Next: PPicElem;
  end;

  TSortMethod = function(elem1, elem2: TData; direction: integer): integer;

var
  choice: byte;
  sortChoice: byte;
  sortDirection: byte;
  head: PPicElem;
  sortedHead: PPicElem;
  a: integer;


  // choice - user option what to do;
  // head - of a main pic list;

procedure clearConsole();
var
  i: integer;
  choice: char;
begin
  for i := 0 to 100 do
    writeln;
end;


procedure printList(head: PPicElem);
var
  list: PPicElem;
begin
  list := head;

  while list^.Next <> nil do
  begin
    writeln('--------------- Another picture -----------------');
    writeln('-------------- ', list^.data.title, ' -------------');

    writeln(list^.data.year);
    writeln(list^.data.genre);
    writeln(list^.data.place);
    writeln(list^.data.shortDescr);
    writeln(list^.data.userRate);
    writeln(list^.data.filename);

    list := list^.Next;

  end;
end;


procedure FetchAllPics(var head: PPicElem);
var
  RedPicList: PPicElem;
  storageFile: file of Tdata;
  current: TData;


begin

  Reset(storageFile, 'dataset.pics');

  new(redPicList);
  head := redPicList;
  While Not Eof(storageFile) Do
  Begin

     Read(storageFile, Current);

     redPicList^.data.title := current.title;
     redPicList^.data.year := current.year;
     redPicList^.data.genre := current.genre;
     redPicList^.data.place := current.place;
     redPicList^.data.shortDescr := current.shortDescr;
     redPicList^.data.userRate := current.userRate;
     redPicList^.data.filename := current.filename;

      new(redPicList^.Next);
      redPicList := redPicList^.Next;

  End;
  redPicList^.Next := nil;
  closeFile(storageFile);



  writeln;


end;

function cmpYear(elem1, elem2: TData; direction: integer): integer;
begin

  if direction = 1  then
  begin

    if (elem1.year > elem2.year) then
      result := 1;
    if (elem1.year < elem2.year) then
      result := -1;
    if (elem1.year = elem1.year) then
      result := 0;
  end
  else
  begin
    if (elem1.year < elem2.year) then
      result := 1;
    if (elem1.year > elem2.year) then
      result := -1;
    if (elem1.year = elem1.year) then
      result := 0;
  end;

end;

function cmpTitle(elem1, elem2: TData; direction: integer): integer;
begin

  if direction = 1 then

  begin
    if (elem1.title > elem2.title) then
      result := 1;
    if (elem1.title < elem2.title) then
      result := -1;
    if (elem1.title = elem1.title) then
      result := 0;
  end
  else
  begin
    if (elem1.title < elem2.title) then
      result := 1;
    if (elem1.title > elem2.title) then
      result := -1;
    if (elem1.title = elem1.title) then
      result := 0;
  end
end;

function cmpRate(elem1, elem2: TData; direction: integer): integer;
begin

  if direction = 1 then
  begin
    if (elem1.userRate > elem2.userRate) then
      result := 1;
    if (elem1.userRate < elem2.userRate) then
      result := -1;
    if (elem1.userRate = elem1.userRate) then
      result := 0;
  end
  else
  begin
    if (elem1.userRate < elem2.userRate) then
      result := 1;
    if (elem1.userRate > elem2.userRate) then
      result := -1;
    if (elem1.userRate = elem1.userRate) then
      result := 0;
  end

end;

// DEBUG

function FindMiddle(head: PPicElem): PPicElem;
var
  slow, fast: PPicElem;
begin
  slow := head;
  fast := head^.Next;
  while (fast <> nil) do
  begin
    fast := fast^.Next;
    if (fast <> nil) then
    begin
      slow := slow^.Next;
      fast := fast^.Next;
    end;
  end;
  FindMiddle := slow;
end;


function Merge(left, right: PPicElem): PPicElem;
var
  AuxResult,  tail: PPicElem;
begin
  AuxResult := nil;
  tail := nil;

  while (left <> nil) and (right <> nil) do
  begin
    if (left^.data.title <= right^.data.title) then
    begin
      if (AuxResult = nil) then
        AuxResult := left
      else
        tail^.Next := left;
      tail := left;
      left := left^.Next;
    end
    else
    begin
      if (AuxResult = nil) then
        AuxResult := right
      else
        tail^.Next := right;
      tail := right;
      right := right^.Next;
    end;
  end;

  if (left <> nil) then
    tail^.Next := left
  else
    tail^.Next := right;

  Merge := AuxResult;
end;


function mergeSort(head: PPicElem {; direction: byte; method: TSortMethod}): PPicElem;

var
  middle, right, left: PPicElem;
  flag: Boolean;
begin
  flag := False;
  while not flag do
  begin
    flag := True;
    if (head = nil) or (head^.Next = nil) then
    begin
      MergeSort := head;
    end
    else
    begin
      middle := FindMiddle(head);
      right := middle^.Next;
      middle^.Next := nil;
      left := head;
      left := MergeSort(left);
      right := MergeSort(right);
      MergeSort := Merge(left, right);
      flag := False;
    end;
  end;
end;



// DEBUG


begin

   FetchAllPics(head);

   repeat

        writeln('Please choose an option:');
        writeln('1. Просмотреть все картины');
        writeln('2. IN DEV Сортировать картины');
        writeln('3. IN DEV Фильтровать картины');
        writeln('4. IN DEV Добавить картину в избранное');
        writeln('5. IN DEV Добавить картине персональную оценку');
        writeln('6. IN DEV Составить слайд-шоу');
        writeln('7. IN DEV Изменить описание картины');
        writeln('8. IN DEV Добавить картину');
        writeln('9. IN DEV Удалить картину');
        writeln('10. IN DEV Просмотреть биографию художника');
        writeln('11. IN DEV Просмотреть информацию о программе');
        writeln('12. IN DEV Просмотреть картины конкретного периода жизни художника');
        writeln('0. To exit');
        readln(choice);
        case choice of
            1: // ПРОСМОТРЕТЬ КАРТИНЫ
            begin
              clearConsole();
              writeln('Выбрана опция просмотреть все картины');

              printList(head);
            end;
            2: // СОРТИРОВАТЬ КАРТИНЫ
            begin
              clearConsole();
              writeln('Выбрана опция сортировать картины');
              writeln('Как сортировать?');
              writeln('1. Прямой порядок');
              writeln('2. Обратный порядок');
              repeat

                readln(sortDirection);

                case sortDirection of

                  1: ;
                  2: ;
                  else
                  begin
                    writeln('Вы ввели неверную цифру. Повторите ввод:');
                  end;
                end;

              until (sortDirection = 1) or (sortDirection = 2);



              writeln('Выберите признак сортировки: ');
              writeln('1. По названию');
              writeln('2. По году');
              writeln('3. По оценке пользователя');

              repeat
                readln(sortChoice);

                case sortChoice of
                  1:
                  begin

                    a := 1;
                    sortedHead := mergeSort(head {, sortDirection, cmpTitle});
                    a := 3;
                    writeln;
                  end;
                  2:
                  begin

                    mergeSort(head {, sortDirection, cmpYear} );
                  end;
                  3:
                  begin

                    mergeSort(head {, sortDirection, cmpUserRate});

                  end;
                  else
                  begin
                    writeln('Вы ввели неверную цифру. Повторите ввод:');
                  end;
                end;

              until (sortChoice = 1) or (sortChoice = 2) or (sortChoice = 3);




               writeln('IN DEVELOPMENT');

            end;
            3:
            begin
              clearConsole();
              writeln('IN DEVELOPMENT');
            end;
            4:
            begin
              clearConsole();
              writeln('IN DEVELOPMENT');
            end;
            5:
            begin
              clearConsole();
               writeln('IN DEVELOPMENT');
            end;
            6:
            begin
              clearConsole();
               writeln('IN DEVELOPMENT');
            end;
            7:
            begin
              clearConsole();
              writeln('IN DEVELOPMENT');
            end;
            8:
            begin
              clearConsole();
              writeln('IN DEVELOPMENT');
            end;
            9:
            begin
              clearConsole();
              writeln('IN DEVELOPMENT');
            end;
            10:
            begin
              clearConsole();
              writeln('IN DEVELOPMENT');
            end;
            11:
            begin
              clearConsole();
              writeln('IN DEVELOPMENT');
            end;
            12:
            begin
              clearConsole();
              writeln('IN DEVELOPMENT');
            end;
            else
            begin
                clearConsole();
                writeln('Invalid choice, please try again.');
            end;
        end;

    until choice = 0;


end.
